#swee---------------------------------------------------------------------
# Title      : Rohde & Schwarz FSL Spectrum Analyzer Epics Protocol File
# Project    :
#---------------------------------------------------------------------
# File       : rsfsl.proto
# Author     : Leticia Garcez Capovilla
# Company    : Brazilian Synchrotron Light Laboratory, LNLS/CNPEM
# Created    : 2018-03-19
# Last update: 2018-03-19
#---------------------------------------------------------------------
# Description:
#
# Defines protocol to use the device as a StreamDevice IOC in EPICS
#
#---------------------------------------------------------------------
# Copyright (c) 2016 Brazilian Synchrotron Light Laboratory, LNLS/CNPEM
#
# This program is free software: you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public License
# as published by the Free Software Foundation, either version 3 of
# the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this program. If not, see
# <http://www.gnu.org/licenses/>.
#---------------------------------------------------------------------
# Revisions  :
# Date        	Version  	Author          	Description
# 2018-mar-19	1.0      	leticiagcapovilla       Created
#---------------------------------------------------------------------

######################################################################
#
# Variable declaration
#
GLOBAL_TIMEOUT = 5000;

######################################################################
#
# Communication setup
#
OutTerminator = CR LF;
InTerminator = LF;
ExtraInput = Ignore;
WriteTimeout = ${GLOBAL_TIMEOUT};
ReadTimeout = ${GLOBAL_TIMEOUT};
ReplyTimeout = ${GLOBAL_TIMEOUT};
#
#

######################################################################
# Reset to default state
outRst {
       out "%{|*RST; *WAI}";
}

######################################################################
# Get identification
inIdn {
	out "*IDN?";
	in "%s";
}

######################################################################
# Reference Level
#
inRefLvl {
    out "DISP:WIND:TRAC:Y:RLEV?";
    in "%f";
}

outRefLvl {
    out "DISP:WIND:TRAC:Y:RLEV %f";
    @init { inRefLvl; };
}

######################################################################
# Reference Level Offset
#
inRefOff {
    out "DISP:WIND:TRAC:Y:RLEV:OFFS?";
    in "%f";
}

outRefOff {
    out "DISP:WIND:TRAC:Y:RLEV:OFFS %f";
    @init { inRefOff; };
}

######################################################################
# Continuous Sweep Mode
#
inSweMode {
    out "INIT:CONT?";
    in "%i";
}

outSweMode {
    out "INIT:CONT %{OFF|ON}";
    @init { inSweMode; };
}

######################################################################
# Sweep Points Number (MIN 101; MAX 32001)
#
inSwePoints {
    out "SWE:POIN?";
    in "%i";
}

outSwePoints {
    out "SWE:POIN %i";
    @init { inSwePoints; };
}

######################################################################
# Trace Data (single sweep --> INIT:CONT OFF)
#
inTrace {
    Separator=",";
    out "INIT;*WAI";
    out "TRAC? TRACE1";
    in "%E";
}

######################################################################
# Center Frequency
#
inFrqCent {
    out "FREQ:CENT?";
    in "%f";
}

outFrqCent {
    out "FREQ:CENT %f";
    @init { inFrqCent; };
}

######################################################################
# Frequency Span
#
inFrqSpan {
    out "FREQ:SPAN?";
    in "%f";
}

outFrqSpan {
    out "FREQ:SPAN %f";
    @init { inFrqSpan; };
}

######################################################################
# Start Frequency
#
inFrqStart {
    out "FREQ:STAR?";
    in "%f";
}

outFrqStart {
    out "FREQ:STAR %f";
    @init { inFrqStart; };
}

######################################################################
# Stop Frequency
#
inFrqStop {
    out "FREQ:STOP?";
    in "%f";
}

outFrqStop {
    out "FREQ:STOP %f";
    @init { inFrqStop; };
}


######################################################################
# Enable Markers (1-4)

inEnblMark1 {
	out "CALC:MARK1:STAT?";
	in "%i";
}

outEnblMark1 {
	out "CALC:MARK1:STAT %i";
	@init { inEnblMark1; };
}

inEnblMark2 {
	out "CALC:MARK2:STAT?";
	in "%i";
}

outEnblMark2 {
	out "CALC:MARK2:STAT %i";
	@init { inEnblMark2; };
}

inEnblMark3 {
	out "CALC:MARK3:STAT?";
	in "%i";
}

outEnblMark3 {
	out "CALC:MARK3:STAT %i";
	@init { inEnblMark3; };
}

inEnblMark4 {
	out "CALC:MARK4:STAT?";
	in "%i";
}

outEnblMark4 {
	out "CALC:MARK4:STAT %i";
	@init { inEnblMark4; };
}

######################################################################
# Markers X Values

inMark1X {
    out "CALC:MARK1:X?";
    in "%f";
}

outMark1X {
    out "CALC:MARK1:X %f";
}

inMark2X {
    out "CALC:MARK2:X?";
    in "%f";
}

outMark2X {
    out "CALC:MARK2:X %f";
}

inMark3X {
    out "CALC:MARK3:X?";
    in "%f";
}

outMark3X {
    out "CALC:MARK3:X %f";
}

inMark4X {
    out "CALC:MARK4:X?";
    in "%f";
}

outMark4X {
    out "CALC:MARK4:X %f";
}

######################################################################
# Markers Y Values

inMark1Y {
    out "CALC:MARK1:Y?";
    in "%f";
}

######################################################################
# Set Marker to Max Peak on Trace

outMarkMax {
    out "%{|CALC:MARK:MAX}";
}

######################################################################
# IQ Data
#
#inIQ {
#    Separator=",";
#    out "INIT:CONT OFF";
#    out "TRAC:IQ:STAT ON";
#    out "TRAC:IQ:SET NORM,10 MHz,32 MHz,IMM,POS,0,10";
#    out "TRAC:IQ:DATA?";
#    in "%E";
#}
